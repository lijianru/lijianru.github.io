import{_ as a,c as s,o as e,a1 as n}from"./chunks/framework.Bw_Y1HHt.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"notebook/es6/对象的扩展.md","filePath":"notebook/es6/对象的扩展.md"}'),t={name:"notebook/es6/对象的扩展.md"},p=n(`<h2 id="属性的简洁表示法" tabindex="-1">属性的简洁表示法 <a class="header-anchor" href="#属性的简洁表示法" aria-label="Permalink to &quot;属性的简洁表示法&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const obj = {</span></span>
<span class="line"><span>    foo,</span></span>
<span class="line"><span>    class() {}, // class是字符串，所以不会因为它属于关键字而报错</span></span>
<span class="line"><span>    *m() {},    // Generator函数前面需要加上*</span></span>
<span class="line"><span>}</span></span></code></pre></div><h2 id="属性名表达式" tabindex="-1">属性名表达式 <a class="header-anchor" href="#属性名表达式" aria-label="Permalink to &quot;属性名表达式&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// ES5</span></span>
<span class="line"><span>obj.foo = true; // 标识符作为属性名</span></span>
<span class="line"><span>obj[&#39;a&#39; + &#39;bc&#39;] = 123   // 表达式作为属性名</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ES6</span></span>
<span class="line"><span>let obj = {</span></span>
<span class="line"><span>    [&#39;a&#39; + &#39;bc&#39;]: 123</span></span>
<span class="line"><span>}</span></span></code></pre></div><blockquote><p>注意：如果表达式是一个对象默认情况下会被自动转为字符串[Object Object]</p></blockquote><h2 id="object-is" tabindex="-1">Object.is() <a class="header-anchor" href="#object-is" aria-label="Permalink to &quot;Object.is()&quot;">​</a></h2><blockquote><p>比较两个值是否严格相等与 === 行为一致但是可以判断+0 与-0 和 NaN</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>Object.is({}, {})       // false</span></span>
<span class="line"><span>Object.is(+0, -0)       // false</span></span>
<span class="line"><span>Object.is(NaN, NaN)     // true</span></span></code></pre></div><h2 id="object-assign" tabindex="-1">Object.assign() <a class="header-anchor" href="#object-assign" aria-label="Permalink to &quot;Object.assign()&quot;">​</a></h2><blockquote><p>将源对象所有的可枚举属性复制到目标对象，第一个参数为目标对象，后面的都是源对象。</p></blockquote><ul><li>后面的同名属性会覆盖前边的</li><li>如果只有一个参数会直接返回该参数</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>var obj = {a: 1};</span></span>
<span class="line"><span>Object.assign(obj) === obj // true，存储地址相同</span></span></code></pre></div><ul><li>参数不是对象会先转换为对象,null 和 undefined 无法转为对象，在首位会报错，在其他位置会跳过。其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了 字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>typeof Object.assign(2) // &quot;Object&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>var v1 = &#39;abc&#39;;</span></span>
<span class="line"><span>var v2 = true;</span></span>
<span class="line"><span>var v3 = 10;</span></span>
<span class="line"><span>var obj = Object.assign({}, v1, v2, v3);</span></span>
<span class="line"><span>console.log(obj); // { &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; }</span></span></code></pre></div><ul><li>只会拷贝可枚举的实义属性和原对象的自身属性(不拷贝继承属性)</li><li>实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>var obj1 = {a: {b: 1}};</span></span>
<span class="line"><span>var obj2 = Object.assign({}, obj1);</span></span>
<span class="line"><span>obj1.a.b = 2;</span></span>
<span class="line"><span>obj2.a.b // 2</span></span></code></pre></div><ul><li>可以处理数组，但会把数组视为对象</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>Object.assign([1, 2, 3], [4, 5]) // [4，5，3]</span></span></code></pre></div><h4 id="用途" tabindex="-1">用途 <a class="header-anchor" href="#用途" aria-label="Permalink to &quot;用途&quot;">​</a></h4><ul><li>为对象添加属性</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class Point {</span></span>
<span class="line"><span>    constructor(x, y) {</span></span>
<span class="line"><span>        Object.assign(this, {x, y});</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><ul><li>为对象添加方法</li><li>拷贝对象，但只能克隆原始对象自身的值，不能克隆它继承的值，要保持继承链可以采用下面代码</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>function clone(origin) {</span></span>
<span class="line"><span>    let originProto = Object.getPrototypeOf(origin);</span></span>
<span class="line"><span>    return Object.assign(Object.create(originProto), origin);</span></span>
<span class="line"><span>}</span></span></code></pre></div><ul><li>合并对象</li><li>为属性指定默认值</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>Object.assign({}, DEFAULTS, options);</span></span></code></pre></div><h2 id="属性的可枚举性和遍历" tabindex="-1">属性的可枚举性和遍历 <a class="header-anchor" href="#属性的可枚举性和遍历" aria-label="Permalink to &quot;属性的可枚举性和遍历&quot;">​</a></h2><h4 id="可枚举性" tabindex="-1">可枚举性 <a class="header-anchor" href="#可枚举性" aria-label="Permalink to &quot;可枚举性&quot;">​</a></h4><blockquote><p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行 为。 Object.getOwnPropertyDescriptor 方法可以获取该属性的描述对象。</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let obj = { foo: 123 };</span></span>
<span class="line"><span>Object.getOwnPropertyDescriptor(obj, &#39;foo&#39;)</span></span>
<span class="line"><span>// {</span></span>
<span class="line"><span>//   value: 123,</span></span>
<span class="line"><span>//   writable: true,</span></span>
<span class="line"><span>//   enumerable: true,</span></span>
<span class="line"><span>//   configurable: true</span></span>
<span class="line"><span>// }</span></span></code></pre></div><blockquote><p>描述对象的 enumerable 属性，称为”可枚举性“，如果该属性为 false 以下操作会忽略当前属性：</p></blockquote><ul><li>for...in 循环：只遍历对象自身的和继承的可枚举的属性。</li><li>Object.keys() ：返回对象自身的所有可枚举的属性的键名。</li><li>JSON.stringify() ：只串行化对象自身的可枚举的属性。</li><li>Object.assign() ： 忽略 enumerable 为 false 的属性，只拷贝对象自身的可枚举的属性。</li></ul><h4 id="属性的遍历" tabindex="-1">属性的遍历 <a class="header-anchor" href="#属性的遍历" aria-label="Permalink to &quot;属性的遍历&quot;">​</a></h4><ul><li>for...in: 循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）</li><li>Object.keys: 返回一个数组，包含对象自身的可枚举属性（不含 Symbol 属性）</li><li>Object.getOwnPropertyNames(obj): 返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）。</li><li>Object.getOwnPropertySymbols: 返回一个数组，包含对象自身的所有 Symbol 属性。</li><li>Reflect.ownKeys: 返回一个数组，包含对象自身的所有属性，不管属性名是 Symbol 或字符串，也不管是否可枚举。 <blockquote><p>以上 5 种方法遍历对象属性都遵循以下次序规则：</p></blockquote></li><li>首先遍历所有属性名为数值的属性，按照数字排序。</li><li>其次遍历所有属性名为字符串的属性，按照生成时间排序。</li><li>最后遍历所有属性名为 Symbol 值的属性，按照生成时间排序。</li></ul><h2 id="object-getownpropertydescriptors" tabindex="-1">Object.getOwnPropertyDescriptors() <a class="header-anchor" href="#object-getownpropertydescriptors" aria-label="Permalink to &quot;Object.getOwnPropertyDescriptors()&quot;">​</a></h2><blockquote><p>返回某个对象所有的自生属性的描述对象</p></blockquote><h4 id="使用场景" tabindex="-1">使用场景 <a class="header-anchor" href="#使用场景" aria-label="Permalink to &quot;使用场景&quot;">​</a></h4><ul><li>解决 Object.assign()无法正确拷贝 get 和 set 属性的问题</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const shallowMerge = (target, source) =&gt; Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));</span></span></code></pre></div><ul><li>配合 Object.create 方法，将对象属性克隆到一个新对象。这属于浅拷贝。</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const clone = Object.create(Object.getPrototypeOf(obj),Object.getOwnPropertyDescriptors(obj));</span></span></code></pre></div><ul><li>实现一个对象继承另一个对象</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const obj = Object.create(</span></span>
<span class="line"><span>    prot,</span></span>
<span class="line"><span>    Object.getOwnPropertyDescriptors({</span></span>
<span class="line"><span>        foo: 123,</span></span>
<span class="line"><span>    })</span></span>
<span class="line"><span>);</span></span></code></pre></div><h2 id="object-setprototypeof" tabindex="-1">Object.setPrototypeOf() <a class="header-anchor" href="#object-setprototypeof" aria-label="Permalink to &quot;Object.setPrototypeOf()&quot;">​</a></h2><blockquote><p>ES6 推荐的设置原型对象的方法，用来设置一个对象的 prototype,如果第一个参数不是对象会转为对象，但返回的还是第一个参数，所以不会产生任何效果</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let proto = {};</span></span>
<span class="line"><span>let obj = { x: 10 };</span></span>
<span class="line"><span>Object.setPrototypeOf(obj, proto);</span></span>
<span class="line"><span>proto.y = 20;</span></span>
<span class="line"><span>proto.z = 40;</span></span>
<span class="line"><span>obj.x // 10</span></span>
<span class="line"><span>obj.y // 20</span></span>
<span class="line"><span>obj.z // 40</span></span></code></pre></div><h2 id="object-getprototypeof" tabindex="-1">Object.getPrototypeOf() <a class="header-anchor" href="#object-getprototypeof" aria-label="Permalink to &quot;Object.getPrototypeOf()&quot;">​</a></h2><blockquote><p>该方法与 Object.setPrototypeOf 方法配套，用于读取一个对象的原型对象。参数不是对象会被转为对象</p></blockquote><h2 id="object-keys" tabindex="-1">Object.keys() <a class="header-anchor" href="#object-keys" aria-label="Permalink to &quot;Object.keys()&quot;">​</a></h2><blockquote><p>返回一个对象自身（不含继承）所有可枚举属性的键名数组</p></blockquote><h2 id="object-values" tabindex="-1">Object.values() <a class="header-anchor" href="#object-values" aria-label="Permalink to &quot;Object.values()&quot;">​</a></h2><blockquote><p>返回一个对象自身（不含继承）所有可枚举属性的键值数组，会过滤属性名为 Symbol 值的属性。</p></blockquote><h2 id="object-entries" tabindex="-1">Object.entries() <a class="header-anchor" href="#object-entries" aria-label="Permalink to &quot;Object.entries()&quot;">​</a></h2><blockquote><p>返回一个对象自身（不含继承）所有可枚举属性的键值对数组, 会过滤属性名为 Symbol 值的属性。</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>var obj = { foo: &#39;bar&#39;, baz: 42 };</span></span>
<span class="line"><span>Object.entries(obj)</span></span>
<span class="line"><span>// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]</span></span></code></pre></div><h2 id="object-fromentries" tabindex="-1">Object.fromEntries() <a class="header-anchor" href="#object-fromentries" aria-label="Permalink to &quot;Object.fromEntries()&quot;">​</a></h2><blockquote><p>Object.entries()的反转</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>Object.fromEntries(new Map([ [&#39;foo&#39;, &#39;bar&#39;], [&#39;baz&#39;, 42] ]))</span></span>
<span class="line"><span>// { foo: &#39;bar&#39;, baz: 42 }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Object.fromEntries([[&#39;foo&#39;, &#39;bar&#39;], [&#39;baz&#39;, 42]])</span></span>
<span class="line"><span>// { foo: &#39;bar&#39;, baz: 42 }</span></span></code></pre></div><h2 id="对象扩展运算符" tabindex="-1">对象扩展运算符（...） <a class="header-anchor" href="#对象扩展运算符" aria-label="Permalink to &quot;对象扩展运算符（...）&quot;">​</a></h2><ul><li>解构赋值，将所有的可遍历但尚未被读取的属性分配到制定的对象</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };</span></span>
<span class="line"><span>x // 1</span></span>
<span class="line"><span>y // 2</span></span>
<span class="line"><span>z // { a: 3, b: 4 }</span></span></code></pre></div><ul><li>扩展运算符，取出参数对象的所有可遍历属性，拷贝到当前对象之中。</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let newObj = { ...obj }</span></span></code></pre></div><ul><li>合并两个对象</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>{ ...obj1, ...obj2 }</span></span></code></pre></div><h4 id="object-assign-与展开运算符的区别" tabindex="-1">Object.assign 与展开运算符的区别 <a class="header-anchor" href="#object-assign-与展开运算符的区别" aria-label="Permalink to &quot;Object.assign 与展开运算符的区别&quot;">​</a></h4><h5 id="相同点" tabindex="-1">相同点 <a class="header-anchor" href="#相同点" aria-label="Permalink to &quot;相同点&quot;">​</a></h5><ul><li>行为一致</li><li>执行的都是浅拷贝</li><li>都是将已有对象的所有可枚举属性拷贝到新构造的对象中</li></ul><h5 id="不同点" tabindex="-1">不同点 <a class="header-anchor" href="#不同点" aria-label="Permalink to &quot;不同点&quot;">​</a></h5><ul><li>Object.assign() 函数会触发 setters，而展开语法则不会</li></ul><h2 id="null-传导运算符-提案" tabindex="-1">Null 传导运算符（提案） <a class="header-anchor" href="#null-传导运算符-提案" aria-label="Permalink to &quot;Null 传导运算符（提案）&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const firstName = (message</span></span>
<span class="line"><span>&amp;&amp; message.body</span></span>
<span class="line"><span>&amp;&amp; message.body.user</span></span>
<span class="line"><span>&amp;&amp; message.body.user.firstName) || &#39;default&#39;;</span></span>
<span class="line"><span>// 简化如下：</span></span>
<span class="line"><span>const firstName = message?.body?.user?.firstName || &#39;default&#39;;</span></span></code></pre></div><blockquote><p>四种用法：</p></blockquote><ul><li>obj?.prop // 读取对象属性</li><li>obj?.[expr] // 同上</li><li>func?.(...args) // 函数或对象方法的调用</li><li>new C?.(...args) // 构造函数的调用</li></ul>`,73),l=[p];function i(o,c,r,b,u,h){return e(),s("div",null,l)}const v=a(t,[["render",i]]);export{g as __pageData,v as default};
