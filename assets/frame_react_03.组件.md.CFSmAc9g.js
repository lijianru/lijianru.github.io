import{_ as e,c as t,o as a,a1 as r}from"./chunks/framework.Bw_Y1HHt.js";const k=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"frame/react/03.组件.md","filePath":"frame/react/03.组件.md"}'),i={name:"frame/react/03.组件.md"},o=r(`<h2 id="props" tabindex="-1">Props <a class="header-anchor" href="#props" aria-label="Permalink to &quot;Props&quot;">​</a></h2><blockquote><p>无论是类组件还是函数组件它们绝对不能修改自己的 props</p></blockquote><h2 id="state" tabindex="-1">state <a class="header-anchor" href="#state" aria-label="Permalink to &quot;state&quot;">​</a></h2><ul><li>不要直接更新状态，应当使用 setState({key: value})</li><li>状态更新可能是异步的 <ul><li>一个生命周期内 React 可以将多个 setState()合并为一个调用来提升性能。</li><li>对于依靠 state 的值来计算下一个状态时应该使用以下形式</li></ul></li></ul><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 该函数将接收先前的状态作为第一个参数，将此次更新被应用时的props做为第二个参数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">prevState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">props</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  counter: prevState.counter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> props.increment,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}));</span></span></code></pre></div><ul><li>state 的更新会被合并，可以分别调用 setState()来单独的更新它们</li></ul><h2 id="生命周期" tabindex="-1">生命周期 <a class="header-anchor" href="#生命周期" aria-label="Permalink to &quot;生命周期&quot;">​</a></h2><p><img src="https://user-images.githubusercontent.com/28643081/70846263-96a9f280-1e92-11ea-8444-38ee929f21c5.png" alt="image"></p><h3 id="组件的挂载" tabindex="-1">组件的挂载 <a class="header-anchor" href="#组件的挂载" aria-label="Permalink to &quot;组件的挂载&quot;">​</a></h3><h4 id="constructor-props" tabindex="-1">constructor(props) <a class="header-anchor" href="#constructor-props" aria-label="Permalink to &quot;constructor(props)&quot;">​</a></h4><ul><li>通过 this.state 赋值对象来初始化内部 state</li><li>为事件处理函数绑定实例</li><li>注意：避免将 props 的值赋值直接赋值给 state，如此做毫无必要，同时还产生了 bug（当父组件传递给子组件的 props 改变的时候并不会影响到子组件的 state）</li></ul><h4 id="static-getderivedstatefromprops-props-state" tabindex="-1">static getDerivedStateFromProps(props, state) <a class="header-anchor" href="#static-getderivedstatefromprops-props-state" aria-label="Permalink to &quot;static getDerivedStateFromProps(props, state)&quot;">​</a></h4><ul><li>getDerivedStateFromProps 会在调用 render 方法之前调用，并且在初始化挂载及后续更新时都会被调用</li><li>它应该返回一个对象来更新 state，如果返回 null 则不更新任何内容，但是派生 state 会导致代码冗余，并且使得组件难以维护</li><li>应用：让组件在 props 变化时更新 state</li><li>注意： <ul><li>不管 props 有没有变化，只要父组件重新渲染，getDerivedStateFromProps 就会被调用，所以直接将 props 复制到 state 是不安全的</li><li>如果需要执行副作用以响应 props 的更改，请改用 componentDidUpdate</li><li>如果指向在 props 更改时重新计算某些数据，请使用 memoization</li></ul></li></ul><h4 id="render" tabindex="-1">render() <a class="header-anchor" href="#render" aria-label="Permalink to &quot;render()&quot;">​</a></h4><ul><li>render()方法是 class 组建中唯一必须实现的方法</li><li>render()函数为纯函数</li></ul><h4 id="componentdidmount" tabindex="-1">componentDidMount() <a class="header-anchor" href="#componentdidmount" aria-label="Permalink to &quot;componentDidMount()&quot;">​</a></h4><ul><li>componentDidMount()会在组件挂载后（插入 DOM 树中）立即调用</li><li>依赖 DOM 节点的初始化应该放在 componentDidMount()函数中</li><li>通过网络请求获取数据的操作最好放在 componentDidMount()函数中</li><li>适合添加订阅，如果在此函数中添加了订阅一定要在 componentDidUnmount()里取消订阅</li><li>可以在 componentDidMount()里直接调用 setState()，它会触发额外的渲染，在此渲染会发生在浏览器更新之前（会导致性能问题，慎用！）</li></ul><h3 id="组件的更新" tabindex="-1">组件的更新 <a class="header-anchor" href="#组件的更新" aria-label="Permalink to &quot;组件的更新&quot;">​</a></h3><h4 id="static-getderivedstatefromprops-props-state-1" tabindex="-1">static getDerivedStateFromProps(props, state) <a class="header-anchor" href="#static-getderivedstatefromprops-props-state-1" aria-label="Permalink to &quot;static getDerivedStateFromProps(props, state)&quot;">​</a></h4><h4 id="shouldcomponentupdate-nextprops-nextstate" tabindex="-1">shouldComponentUpdate(nextProps, nextState) <a class="header-anchor" href="#shouldcomponentupdate-nextprops-nextstate" aria-label="Permalink to &quot;shouldComponentUpdate(nextProps, nextState)&quot;">​</a></h4><ul><li>根据 shouldComponentUpdate()的返回值（true/false）判断 React 组件是否渲染，默认值为 true</li><li>当 props 或 state 发生变化时，shouldComponentUpdate()会在渲染执行前被调用，首次渲染或者使用 forceUpdate()时不会调用该方法</li><li>此方法仅作为性能优化的方式存在</li><li>再后续的版本中可能会将 shouldComponentUpdate 视为提示而不是严格的指令，并且当返回 false 时任然可能导致组建的重新渲染</li></ul><h4 id="render-1" tabindex="-1">render() <a class="header-anchor" href="#render-1" aria-label="Permalink to &quot;render()&quot;">​</a></h4><h4 id="getsnapshotbeforeupdate-prevprops-prevstate" tabindex="-1">getSnapshotBeforeUpdate(prevProps, prevState) <a class="header-anchor" href="#getsnapshotbeforeupdate-prevprops-prevstate" aria-label="Permalink to &quot;getSnapshotBeforeUpdate(prevProps, prevState)&quot;">​</a></h4><ul><li>getSnapshotBeforeUpdate()在最近一次渲染输出（提交到 DOM 节点）之前调用</li><li>getSnapshotBeforeUpdate()是得组件在发生更改之前从 DOM 中捕获一些信息</li><li>getSnapshotBeforeUpdate()的返回值将作为参数传递给 componentDidUpdate()</li><li>应用：不常用，处理滚动位置等</li></ul><h4 id="componentdidupdate-prevprops-prevstate-snapshot" tabindex="-1">componentDidUpdate(prevProps, prevState, snapshot) <a class="header-anchor" href="#componentdidupdate-prevprops-prevstate-snapshot" aria-label="Permalink to &quot;componentDidUpdate(prevProps, prevState, snapshot)&quot;">​</a></h4><ul><li>componentDidUpdate()会在更新后立即被调用，首次渲染不会执行此方法</li><li>最更新前后如果对 props 进行了对比，也可以在此方法中进行网络请求</li><li>也可以在此方法里直接调用 setState()，但必须将它包裹在一个调价语句中，否则会导致死循环</li><li>如果组件实现了 getSnapshotBeforeUpdate()生命周期，则它的返回值将作为 componentDidUpdate()的第三个参数进行传递，否则此参数为 undefined</li><li>注意：如果 shouldComponentUpdate()返回值为 false，则不会调用 componentDidUpdate()</li></ul><h3 id="组件的卸载" tabindex="-1">组件的卸载 <a class="header-anchor" href="#组件的卸载" aria-label="Permalink to &quot;组件的卸载&quot;">​</a></h3><h4 id="componentwillunmount" tabindex="-1">componentWillUnmount() <a class="header-anchor" href="#componentwillunmount" aria-label="Permalink to &quot;componentWillUnmount()&quot;">​</a></h4><ul><li>会在组件卸载或者销毁之前直接调用</li><li>在此方法中执行必要的清理操作，例如：清除 timer，取消网络请求或者消除在 componentDidMount()中创建的订阅等</li></ul><h3 id="错误的处理" tabindex="-1">错误的处理 <a class="header-anchor" href="#错误的处理" aria-label="Permalink to &quot;错误的处理&quot;">​</a></h3><h4 id="static-getderivedstatefromerror-error" tabindex="-1">static getDerivedStateFromError(error) <a class="header-anchor" href="#static-getderivedstatefromerror-error" aria-label="Permalink to &quot;static getDerivedStateFromError(error)&quot;">​</a></h4><ul><li>此生命周期会在后代组件抛出错误后被调用，他讲抛出的错误作为参数，并返回一个值以更新 state</li><li>注意：getDerivedStateFromError()会在渲染阶段调用，因此不允许出现副作用，如遇此类情况请改用 componentDidCatch()</li></ul><h4 id="componentdidcatch-error-info" tabindex="-1">componentDidCatch(error, info) <a class="header-anchor" href="#componentdidcatch-error-info" aria-label="Permalink to &quot;componentDidCatch(error, info)&quot;">​</a></h4><ul><li>此生命周期在后代组件抛出错误后被调用，它接受两个参数： <ul><li>error: 抛出的错误</li><li>info: 带有 componentStack key 的对象，其中包含有关组件引发错误的栈信息</li></ul></li><li>componentDidCatch()会在提交阶段被调用，因此允许执行副作用</li><li>注意：在发生错误时可以通过 setState 使用 componentDidCatch()渲染降级 UI，但在未来的版本中将不推荐这样的做法。可以使用 getDerivedStateFromError()来处理降级渲染</li></ul><h2 id="其他-api" tabindex="-1">其他 API <a class="header-anchor" href="#其他-api" aria-label="Permalink to &quot;其他 API&quot;">​</a></h2><h3 id="setstate" tabindex="-1">setState() <a class="header-anchor" href="#setstate" aria-label="Permalink to &quot;setState()&quot;">​</a></h3><h4 id="setstate-updater-callback" tabindex="-1">setState(updater[, callback]) <a class="header-anchor" href="#setstate-updater-callback" aria-label="Permalink to &quot;setState(updater[, callback])&quot;">​</a></h4><ul><li>setState()将对组件 state 的更改排入队列，并通知 React 需要使用更新后的 state 重新渲染此组件及其子组件</li><li>为了更好的感知性能，React 会延迟调用 setState()，然后通过一次传递更新多个组件。React 不会保证 state 的变更会立即生效。</li><li>setState()并不总是立即更新组件，所以使用 componentDidUpdate()或者 setState()的回调函数获取更新后的 state 更安全</li></ul><h4 id="setstate-state-props-statechange" tabindex="-1">setState((state, props) =&gt; stateChange) <a class="header-anchor" href="#setstate-state-props-statechange" aria-label="Permalink to &quot;setState((state, props) =&gt; stateChange)&quot;">​</a></h4><h3 id="component-forceupdate-callback" tabindex="-1">component.forceUpdate(callback) <a class="header-anchor" href="#component-forceupdate-callback" aria-label="Permalink to &quot;component.forceUpdate(callback)&quot;">​</a></h3><ul><li>默认情况下，当组件的 state 或 props 发生变化时，组件将重新渲染。如果 render()方法依赖于其他数据，则可以调用 forceUpdate 强制让组件重新渲染</li><li>调用 forceUpdate 将使组件调用 render 方法，此操作会跳过该组件的 shouldComponentUpdate 方法</li><li>避免使用 forceUpdate，尽量在 render 中使用 this.props 和 this.state</li></ul><h2 id="class-属性" tabindex="-1">class 属性 <a class="header-anchor" href="#class-属性" aria-label="Permalink to &quot;class 属性&quot;">​</a></h2><h3 id="defaultprops" tabindex="-1">defaultProps <a class="header-anchor" href="#defaultprops" aria-label="Permalink to &quot;defaultProps&quot;">​</a></h3><ul><li>为 class 组件添加默认的 props</li></ul><h3 id="displayname" tabindex="-1">displayName <a class="header-anchor" href="#displayname" aria-label="Permalink to &quot;displayName&quot;">​</a></h3><ul><li>多用于调试消息</li></ul>`,46),s=[o];function l(n,p,d,h,c,u){return a(),t("div",null,s)}const f=e(i,[["render",l]]);export{k as __pageData,f as default};
