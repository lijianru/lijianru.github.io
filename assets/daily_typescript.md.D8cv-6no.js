import{_ as e,c as l,o as i,a3 as t}from"./chunks/framework.CScuXPqu.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"daily/typescript.md","filePath":"daily/typescript.md"}'),a={name:"daily/typescript.md"},n=t('<h2 id="interface和type的区别是什么" tabindex="-1">interface和type的区别是什么？ <a class="header-anchor" href="#interface和type的区别是什么" aria-label="Permalink to &quot;interface和type的区别是什么？&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><ul><li>继承和扩展： <ul><li>interface 使用 extends 进行继承，适用于面向对象的设计模式。</li><li>type 使用交叉类型进行扩展，适用于函数式编程风格。</li></ul></li><li>功能和灵活性： <ul><li>interface 主要用于定义对象和类的结构。</li><li>type 更灵活，除了对象外，还可以定义联合类型、交叉类型、元组等。</li></ul></li><li>声明合并： <ul><li>interface 支持声明合并。</li><li>type 不支持声明合并。</li></ul></li></ul></details><h2 id="any-never-和unknown的区别是什么" tabindex="-1">any, never 和unknown的区别是什么？ <a class="header-anchor" href="#any-never-和unknown的区别是什么" aria-label="Permalink to &quot;any, never 和unknown的区别是什么？&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><ul><li>any： <ul><li>允许对其进行任何操作，不进行类型检查。</li><li>不推荐使用，容易导致类型安全问题。</li></ul></li><li>unknown： <ul><li>表示未知类型，必须在使用之前进行类型检查。</li><li>更安全的 any 替代品，适合用于接收任意类型的变量，但要求进行显式的类型保护。</li></ul></li><li>never： <ul><li>表示永远不会存在的值，通常用于抛出异常或无限循环的函数返回类型。</li><li>在类型保护中，用于处理不应该存在的分支。</li></ul></li></ul></details><h2 id="typescript内置的工具类型有哪些" tabindex="-1">typescript内置的工具类型有哪些？ <a class="header-anchor" href="#typescript内置的工具类型有哪些" aria-label="Permalink to &quot;typescript内置的工具类型有哪些？&quot;">​</a></h2><p><a href="./../frame/typescript/02.类型.html#常用工具类型">工具类型</a></p>',6),r=[n];function s(c,o,p,u,d,y){return i(),l("div",null,r)}const h=e(a,[["render",s]]);export{m as __pageData,h as default};
