import{_ as s,c as i,o as a,a3 as l}from"./chunks/framework.CScuXPqu.js";const y=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"daily/javaScript-08-其他.md","filePath":"daily/javaScript-08-其他.md"}'),t={name:"daily/javaScript-08-其他.md"},n=l(`<h2 id="经常使用的-es6-新特性" tabindex="-1">经常使用的 ES6 新特性 <a class="header-anchor" href="#经常使用的-es6-新特性" aria-label="Permalink to &quot;经常使用的 ES6 新特性&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><ul><li>let, const</li><li>模板字符串</li><li>箭头函数</li><li>函数参数的默认值</li><li>扩展/剩余运算符</li><li>解构</li><li>class</li><li>promise</li></ul></details><h2 id="深度优先遍历和广度优先遍历" tabindex="-1">深度优先遍历和广度优先遍历 <a class="header-anchor" href="#深度优先遍历和广度优先遍历" aria-label="Permalink to &quot;深度优先遍历和广度优先遍历&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><p>以遍历一个 dom 节点为例：</p><ul><li>深度优先遍历：深度优先遍历是一种从起始节点出发，尽可能深入到子节点的遍历方式。当一个节点的所有子节点都被访问过后，遍历会回溯到它的父节点继续进行未访问的子节点的遍历。</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> deepTraversal</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">nodeList</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (node </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    nodeList.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> children </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node.children;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> children.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      deepTraversal1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(children[i], nodeList);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nodeList;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><ul><li>广度优先遍历：广度优先遍历是一种从起始节点出发，按层级逐层向外扩展的遍历方式。每一层的所有节点都被访问后，才开始访问下一层的节点。</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> widthTraversal</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nodes </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> stack </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (node) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    stack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (stack.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> item </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> stack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">shift</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> children </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> item.children;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      nodes.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(item);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> children.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        stack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(children[i]);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nodes;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div></details><h2 id="settimeout-倒计时为什么会出现误差" tabindex="-1">setTimeout 倒计时为什么会出现误差 <a class="header-anchor" href="#settimeout-倒计时为什么会出现误差" aria-label="Permalink to &quot;setTimeout 倒计时为什么会出现误差&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><ul><li>setTimeout 只是将事件插入了任务队列，必须等到当前代码(执行栈)执行完，才会执行它指定的回调函数。要是当前的代码消耗时间很长， setTimeout 也有可能要等很久，所以并没有办法保证回调函数一定在 setTimeout 指定的时间执行，所以 setTimeout 的第二个参数表示的是最小时间。</li><li>HTML 标准规定了 setTimeout 的第二个参数的最小值不能小于 4ms，如果低于这个值则默认为 4ms。</li></ul></details><h2 id="为什么需要组件化和模块化" tabindex="-1">为什么需要组件化和模块化？ <a class="header-anchor" href="#为什么需要组件化和模块化" aria-label="Permalink to &quot;为什么需要组件化和模块化？&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><ul><li>组件化能提高代码的复用性，降低维护的成本</li><li>模块化能避免变量污染和命名冲突，提高代码的复用率，降低维护成本，方便进行依赖管理</li></ul></details><h2 id="谈谈你对前端模块化的理解" tabindex="-1">谈谈你对前端模块化的理解 <a class="header-anchor" href="#谈谈你对前端模块化的理解" aria-label="Permalink to &quot;谈谈你对前端模块化的理解&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><p>前端模块化是指将前端代码按照功能和职责划分为多个独立且互相依赖的模块，通过模块化的方式组织和管理代码，提升代码的可维护性、可复用性和可读性。模块化不仅适用于JavaScript代码，还可以应用于CSS等前端资源。</p></details><h2 id="简述对-web-worker-的理解" tabindex="-1">简述对 Web Worker 的理解 <a class="header-anchor" href="#简述对-web-worker-的理解" aria-label="Permalink to &quot;简述对 Web Worker 的理解&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><ul><li>Web Worker 的作用就是为 JavaScript 创造多线程环境，在主线程运行的同时允许 Worker 线程在后台运行，两者互不干扰。</li><li>遵循同源策略</li><li>worker 线程无法读取主线程所在网页的 DOM 元素，无法使用 document、window 等对象</li><li>worker 线程不与主线程在同一个上下文环境，它们仅能通过消息机制完成通信</li><li>worker 线程可以通过 XMLHttpRequest 对象发出 ajax 请求</li></ul></details><h2 id="es6-模块和-commonjs-模块的差异是什么" tabindex="-1">ES6 模块和 CommonJS 模块的差异是什么？ <a class="header-anchor" href="#es6-模块和-commonjs-模块的差异是什么" aria-label="Permalink to &quot;ES6 模块和 CommonJS 模块的差异是什么？&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><ul><li>导出导入的方式不同，ES6 使用 export/import。而 CommonJS 使用 module.export/require</li><li>ES6 模块自动采用严格模式，无论模块开头是否写了 use strict</li><li>ES6 模块的顶层 this 指向 undefined。而 CommonJS 模块的顶层 this 指向当前模块。</li><li>ES6 模块在编译的时候就能确定模块的依赖关系，以及输入输出的变量。而 CommonJS 模块是运行时加载。</li><li>ES6 模块输出的是值的引用，如果原始的值改变了，import 加载的值也会改变。而 CommonJS 模块一旦输出一个值，模块内部变化就影响不到这个值了。</li></ul></details><h2 id="解决跨域的方法有哪些" tabindex="-1">解决跨域的方法有哪些？ <a class="header-anchor" href="#解决跨域的方法有哪些" aria-label="Permalink to &quot;解决跨域的方法有哪些？&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><ul><li>CORS：只要服务器设置了 Access-Control-Allow-Origin 就可以开启 CORS。该属性表示那些域名可以访问资源。 <ul><li>简单请求，同时满足以下两个条件就属于简单请求 <ul><li>使用以下方法 <ul><li>get</li><li>head</li><li>post</li></ul></li><li>Content-Type 的值为以下三者之一 <ul><li>text/plain</li><li>multipart/form-data</li><li>application/x-www-form-urlencoded</li></ul></li></ul></li><li>复杂请求，不符合以上条件的就是复杂请求。复杂请求会在正式通信之前增加一次 option 方法的预检查，通过该请求来知道是否允许跨域请求。</li></ul></li></ul><p>存在的问题：对于 CORS 请求，只能拿到 response header 中的 6 个基本字段(Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma)，如果想拿到其他的字段就必须在 Access-Control-Expose-Headers 里指定需要的字段</p><ul><li>nginx 反向代理</li><li>jsonp: 只支持 get 请求</li><li>websocket</li><li>postMessage</li><li>node 中间件</li></ul></details><h2 id="堆和栈的区别" tabindex="-1">堆和栈的区别 <a class="header-anchor" href="#堆和栈的区别" aria-label="Permalink to &quot;堆和栈的区别&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><table><thead><tr><th>特性</th><th>栈（Stack）</th><th>堆（Heap）</th></tr></thead><tbody><tr><td>内存分配</td><td>编译器自动分配和释放</td><td>程序员手动分配和释放</td></tr><tr><td>分配方式</td><td>连续的内存块</td><td>不连续的内存块</td></tr><tr><td>管理方式</td><td>通过栈指针管理</td><td>通过自由链表或其他数据结构管理</td></tr><tr><td>生命周期</td><td>函数调用期间存在，函数返回后销毁</td><td>由程序员控制，显式释放或垃圾回收</td></tr><tr><td>性能</td><td>分配和释放速度快</td><td>分配和释放速度较慢</td></tr><tr><td>内存使用</td><td>通常较小，适用于临时存储</td><td>通常较大，适用于长期或共享数据</td></tr><tr><td>安全性</td><td>自动管理内存，减少内存泄漏风险</td><td>手动管理内存，容易出现内存泄漏和碎片化</td></tr></tbody></table></details><h2 id="babel-编译原理" tabindex="-1">Babel 编译原理 <a class="header-anchor" href="#babel-编译原理" aria-label="Permalink to &quot;Babel 编译原理&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><ol><li><p>解析（Parsing）： 词法分析（Lexical Analysis）：将源码字符串转换为标记（tokens），这些标记是源代码的基本组成部分，如关键字、标识符、操作符和字面量。 语法分析（Syntax Analysis）：将标记流转换为抽象语法树（AST，Abstract Syntax Tree）。AST 是源代码结构的树状表示，每个节点代表源码中的一个结构部分。</p></li><li><p>转换（Transforming）： 在这一步骤中，Babel 使用插件来遍历和修改 AST 节点。这些插件负责将新语法转换为等效的旧语法。</p></li><li><p>生成（Generating）： 最后，Babel 将转换后的 AST 转回为代码字符串。这一步骤称为代码生成（Code Generation），生成的代码可以在旧版本的 JavaScript 环境中运行。</p></li></ol></details><h2 id="代码复用的方式" tabindex="-1">代码复用的方式 <a class="header-anchor" href="#代码复用的方式" aria-label="Permalink to &quot;代码复用的方式&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><ul><li>封装</li><li>继承</li><li>借用（apply/call）</li></ul></details><h2 id="常见的设计模式有哪些" tabindex="-1">常见的设计模式有哪些？ <a class="header-anchor" href="#常见的设计模式有哪些" aria-label="Permalink to &quot;常见的设计模式有哪些？&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><ul><li>JS 工厂模式</li><li>JS 构造函数模式</li><li>JS 原型模式</li><li>观察者模式</li><li>发布订阅模式</li></ul></details>`,24),e=[n];function h(k,p,r,d,E,o){return a(),i("div",null,e)}const g=s(t,[["render",h]]);export{y as __pageData,g as default};
