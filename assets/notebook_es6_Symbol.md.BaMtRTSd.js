import{_ as o,c as a,o as e,a3 as l}from"./chunks/framework.CScuXPqu.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"notebook/es6/Symbol.md","filePath":"notebook/es6/Symbol.md"}'),t={name:"notebook/es6/Symbol.md"},s=l(`<h2 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h2><blockquote><p>ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型， 前六种是： undefined 、 null 、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p></blockquote><ul><li>对象的属性名现在可以有两种类型：字符串和 Symbol 类型</li><li>Symbol 函数前不能使用 new 命令</li><li>Symbol 函数接受一个字符串作为参数表示 Symbol 实例的描述</li><li>如果参数是一个对象就会调用该对象的 toString 方法将其转为字符串然后生成一个 Symbol 值</li><li>Symbol 值不能与其他的类型的值进行运算，会报错</li><li>Symbol 值可以显示的转为字符串和布尔值，但不能转为数值</li></ul><h2 id="作为属性名的-symbol" tabindex="-1">作为属性名的 Symbol <a class="header-anchor" href="#作为属性名的-symbol" aria-label="Permalink to &quot;作为属性名的 Symbol&quot;">​</a></h2><blockquote><p>由于每个 Symbol 都是不相等的，就能保证不会出现同名属性</p></blockquote><h2 id="消除魔术字符串" tabindex="-1">消除魔术字符串 <a class="header-anchor" href="#消除魔术字符串" aria-label="Permalink to &quot;消除魔术字符串&quot;">​</a></h2><blockquote><p>魔术字符串指的是在代码中多次出现与代码形成强耦合的某一个具体字符串或者数值。应该消除魔术字符串改为含义清晰的变量代替</p></blockquote><h2 id="属性名的遍历" tabindex="-1">属性名的遍历 <a class="header-anchor" href="#属性名的遍历" aria-label="Permalink to &quot;属性名的遍历&quot;">​</a></h2><blockquote><p>Symbol 作为属性名，该属性不会出现在 for...in 、 for...of 循环中，也不会 被 Object.keys() 、 Object.getOwnPropertyNames() 、 JSON.stringify()返回。 Object.getOwnPropertySymbols 用于返回一个对象所有的 Symbol 属性名。</p></blockquote><h2 id="symbol-for" tabindex="-1">Symbol.for() <a class="header-anchor" href="#symbol-for" aria-label="Permalink to &quot;Symbol.for()&quot;">​</a></h2><blockquote><p>Symbol.for()接受一个字符串然后搜索有没有该参数作为名称的 Symbol 值，有则返回，没有就创建一个并返回</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>Symbol.for(&quot;bar&quot;) === Symbol.for(&quot;bar&quot;)  // true</span></span>
<span class="line"><span>Symbol(&quot;bar&quot;) === Symbol(&quot;bar&quot;)          // false</span></span></code></pre></div><h2 id="symbol-keyfor" tabindex="-1">Symbol.keyFor() <a class="header-anchor" href="#symbol-keyfor" aria-label="Permalink to &quot;Symbol.keyFor()&quot;">​</a></h2><blockquote><p>返回一个已经登记的 Symbol 类型的 key</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>var s1 = Symbol.for(&quot;foo&quot;);</span></span>
<span class="line"><span>Symbol.keyFor(s1) // &quot;foo&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>var s2 = Symbol(&quot;foo&quot;);</span></span>
<span class="line"><span>Symbol.keyFor(s2) // undefined</span></span></code></pre></div><h4 id="注意-symbol-for-为-symbol-值登记的名字-是全局环境的-可以在不同的-iframe-或-service-worker-中取到同一个值。" tabindex="-1">注意：Symbol.for 为 Symbol 值登记的名字，是全局环境的，可以在不同的 iframe 或 service worker 中取到同一个值。 <a class="header-anchor" href="#注意-symbol-for-为-symbol-值登记的名字-是全局环境的-可以在不同的-iframe-或-service-worker-中取到同一个值。" aria-label="Permalink to &quot;注意：Symbol.for 为 Symbol 值登记的名字，是全局环境的，可以在不同的 iframe 或 service worker 中取到同一个值。&quot;">​</a></h4><h2 id="类型" tabindex="-1">类型 <a class="header-anchor" href="#类型" aria-label="Permalink to &quot;类型&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>typeof Symbol() === &#39;symbol&#39;</span></span>
<span class="line"><span>typeof Symbol(&#39;ConardLi&#39;) === &#39;symbol&#39;</span></span></code></pre></div><h2 id="应用" tabindex="-1">应用 <a class="header-anchor" href="#应用" aria-label="Permalink to &quot;应用&quot;">​</a></h2><ul><li><p>防止 XSS</p><blockquote><p>在 React 的 ReactElement 对象中有一个$$typeof属性，它是一个Symbol类型的变量，React渲染时会把没有$$typeof 标识，以及规则校验不通过的组件过滤掉。 如果前端需要渲染后台存储的 JSON 对象，由于 JSON 中不能存储 Symbol 类型的变量，所以就能将它过滤掉。</p></blockquote></li><li><p>私有属性</p><blockquote><p>借助 Symbol 类型的不可枚举，我们可以在类中模拟私有属性</p></blockquote></li><li><p>防止属性污染</p><blockquote><p>在某些情况下我们可能需要为对象添加一个属性，此时就有可能造成属性覆盖，用 Symbol 作为对象属性可以保证永远不会出现同名属性。</p></blockquote></li></ul><h2 id="内置的-symbol-值" tabindex="-1">内置的 Symbol 值 <a class="header-anchor" href="#内置的-symbol-值" aria-label="Permalink to &quot;内置的 Symbol 值&quot;">​</a></h2><blockquote><p>11 个内置的 Symbol 值</p></blockquote>`,22),n=[s];function r(i,b,p,c,m,u){return e(),a("div",null,n)}const d=o(t,[["render",r]]);export{h as __pageData,d as default};
