import{_ as l,c as i,o as t,a3 as e}from"./chunks/framework.CScuXPqu.js";const S=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"daily/浏览器&网络&安全&性能优化.md","filePath":"daily/浏览器&网络&安全&性能优化.md"}'),a={name:"daily/浏览器&网络&安全&性能优化.md"},s=e('<h2 id="http-1-0-1-1-2-0-的特性和区别" tabindex="-1">http 1.0，1.1，2.0 的特性和区别 <a class="header-anchor" href="#http-1-0-1-1-2-0-的特性和区别" aria-label="Permalink to &quot;http 1.0，1.1，2.0 的特性和区别&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><p>特性</p><ul><li>http 1.0 <ul><li>无状态：服务器不跟踪记录请求过的状态</li><li>无连接：浏览器每次请求都需要建立 tcp 连接（无连接会导致无法复用连接和请求阻塞）</li></ul></li><li>http 1.1 <ul><li>长连接：新增了 Connection 字段，可以设置 keep-live 值保持连接不断开</li><li>管道化：基于上面长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回的</li><li>缓存的处理：新增字段 cache-control</li><li>断点传输：在上传/下载资源时，如果资源过大，将其分割为多个部分，分别上传/下载，如果遇到网络故障，可以从已经上传/下载好的地方继续请求，不用从头开始，提高效率</li></ul></li><li>http 2.0 - 二进制分帧：将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码 - 多路复用：在共享 TCP 链接的基础上同时发送请求和响应 - 头部压缩 - 服务器推送：服务器可以额外的向客户端推送资源，而无需客户端明确的请求</li></ul><p>区别</p><ul><li>http1.0 到 http1.1 的主要区别，就是从无连接到长连接</li><li>http2.0 对比 1.X 版本主要区别就是多路复用</li></ul></details><h2 id="http-和-https-的区别" tabindex="-1">http 和 https 的区别 <a class="header-anchor" href="#http-和-https-的区别" aria-label="Permalink to &quot;http 和 https 的区别&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><ul><li>http 全称超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准</li><li>https 简单的讲就是 http 的安全版，即在 http 下加入 SSL 层</li><li>https 协议需要到数字证书认证机构申请证书</li><li>http 信息传输是明文传输，https 则是具有安全性的 SSL 加密传输</li><li>http 页面的响应速度比 https 快。http 使用 TCP 三次握手建立连接，客户端和服务器需要交换三个包； 而 https 除了 TCP 的三个包还要加上 SSL 握手的 9 个包，一共 12 个包。</li><li>http 和 https 使用完全不同的链接方式，用的端口号也不一致，前者是 80 后则是 443</li><li>https 比 http 更耗费服务器资源</li></ul></details><h2 id="http-的状态码" tabindex="-1">http 的状态码 <a class="header-anchor" href="#http-的状态码" aria-label="Permalink to &quot;http 的状态码&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><ul><li>2xx <ul><li>200：从客户端发来的请求在服务端被正常处理了</li><li>202：服务器已接受请求，但是未处理</li><li>204：服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分</li></ul></li><li>3xx <ul><li>301：永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI</li><li>302：临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。</li></ul></li><li>4xx <ul><li>400：该状态码表示请求报文中存在语法错误</li><li>401：认证失败</li><li>403：该状态码表明对请求资源的访问被服务器拒绝了</li><li>404：无法找到请求的资源</li></ul></li><li>5xx <ul><li>500：该状态码表明服务器端在执行请求时发生了错误</li><li>503：该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求</li></ul></li></ul></details><h2 id="get-和-post-请求的区别" tabindex="-1">get 和 post 请求的区别 <a class="header-anchor" href="#get-和-post-请求的区别" aria-label="Permalink to &quot;get 和 post 请求的区别&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><table><thead><tr><th style="text-align:center;">请求方式</th><th style="text-align:center;">get</th><th style="text-align:center;">post</th></tr></thead><tbody><tr><td style="text-align:center;">参数位置</td><td style="text-align:center;">参数拼接在 url 的后面</td><td style="text-align:center;">参数在请求体内</td></tr><tr><td style="text-align:center;">参数的大小</td><td style="text-align:center;">受浏览器 url 大小限制，不超过 32k</td><td style="text-align:center;">1G</td></tr><tr><td style="text-align:center;">适用场景</td><td style="text-align:center;">从服务器获取数据</td><td style="text-align:center;">向服务器提交数据</td></tr><tr><td style="text-align:center;">安全性</td><td style="text-align:center;">参数携带在 url 中，安全性低</td><td style="text-align:center;">相对于 get，安全性更高</td></tr></tbody></table></details><h2 id="get-请求传参长度有无限制" tabindex="-1">get 请求传参长度有无限制？ <a class="header-anchor" href="#get-请求传参长度有无限制" aria-label="Permalink to &quot;get 请求传参长度有无限制？&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><ul><li>HTTP 协议并未规定 get 和 post 的参数大小</li><li>浏览器或者 web 服务器限制了 URL 的长度所以限制了 get 传参的大小</li><li>不同浏览器和 web 服务器限制的最大长度是不一样的</li></ul></details><h2 id="性能优化的方式有哪些" tabindex="-1">性能优化的方式有哪些 <a class="header-anchor" href="#性能优化的方式有哪些" aria-label="Permalink to &quot;性能优化的方式有哪些&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><ul><li>从编码的角度 <ul><li>html <ul><li>减少不必要的 DOM，避免不必要的 DOM 层层嵌套</li><li>避免<img src="">空标签，因为 src 为空时浏览器任然会发起请求</li><li>图片提前指定宽高或者脱离文档流，这样能减少因图片加载而导致的页面回流</li><li>语义化标签，有利于 SEO 和浏览器的解析</li><li>减少 table 布局</li><li>在 header 引入 css，在 body 底部引入 js</li></ul></li><li>css <ul><li>使用 class，避免一层层的向下查找子节点</li></ul></li><li>js <ul><li>数据扁平化，有利于数据的读取和维护</li><li>尽可能的减少循环的次数，完成循环的目的后尽量终止循环</li><li>尽量避免 for...in 循环，因为他会枚举原型对象，耗时大于普通的循环</li><li>减少访问 DOM 的次数，如需多次访问，尽量将其缓存于变量中</li><li>多次操作 DOM 尽量合并为一次操作，如在 JS 中修改样式等</li><li>避免对计算属性的访问，如：offsetTop，getComputedStyle 等</li><li>使用事件委托，避免大量的事件绑定</li></ul></li></ul></li><li>从其他的角度 <ul><li>合理运用浏览器的缓存</li><li>利用浏览器并行请求的功能，适当的合并/拆分资源</li><li>混淆/压缩代码，开启 gzip 压缩</li><li>小的图片合并成雪碧图，低于 5k 的图片可以转换为 base64 内嵌</li><li>将静态资源放到 CDN 服务器</li><li>非关键性的资源尽可能异步加载和懒加载</li><li>路由懒加载</li></ul></li></ul></details><h2 id="跨页面通信的方式有哪些" tabindex="-1">跨页面通信的方式有哪些 <a class="header-anchor" href="#跨页面通信的方式有哪些" aria-label="Permalink to &quot;跨页面通信的方式有哪些&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><ul><li>父页面通过 window.open(url, name)方式打开的子页面可以获取句柄，然后通过 postMessage 完成通信需求 <ul><li>只能与自己打开的页面完成通信，应用面比较窄</li><li>在跨域场景中也能使用该方式</li></ul></li><li>同源下共享 localStorage 与监听 window.onstorage <ul><li>跨域场景下需要配合其他方案使用</li><li>API 简洁，兼容性比较好</li></ul></li></ul></details><h2 id="从输入-url-到展示出页面经历了哪些过程" tabindex="-1">从输入 url 到展示出页面经历了哪些过程？ <a class="header-anchor" href="#从输入-url-到展示出页面经历了哪些过程" aria-label="Permalink to &quot;从输入 url 到展示出页面经历了哪些过程？&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><ul><li>网络通信 <ul><li>DNS 将域名解析为 IP 地址</li><li>建立 TCP 链接（三次握手）</li><li>浏览器向 WEB 服务器发起 HTTP 请求</li><li>WEB 服务器将结果返回给浏览器</li><li>关闭 TCP 链接（四次挥手）</li></ul></li><li>浏览器渲染 <ul><li>浏览器解析 HTML 生成 DOM tree</li><li>解析 CSS 生成 CSSOM Tree</li><li>解析完成后浏览器引擎会通过 DOM tree 和 CSSOM Tree 来构造 Render Tree</li><li>布局（layout）Render Tree，计算每个节点的几何信息</li><li>绘制（paint）Render Tree，绘制页面像素信息</li><li>将像素发送给 GPU，将各个节点绘制到屏幕上</li></ul></li></ul></details><h2 id="浏览器的渲染机制是什么" tabindex="-1">浏览器的渲染机制是什么？ <a class="header-anchor" href="#浏览器的渲染机制是什么" aria-label="Permalink to &quot;浏览器的渲染机制是什么？&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><ul><li>浏览器解析 HTML 生成 DOM tree</li><li>解析 CSS 生成 CSSOM Tree</li><li>解析完成后浏览器引擎会通过 DOM tree 和 CSSOM Tree 来构造 Render Tree</li><li>布局（layout）Render Tree，计算每个节点的几何信息</li><li>绘制（paint）Render Tree，绘制页面像素信息</li><li>将像素发送给 GPU，将各个节点绘制到屏幕上</li></ul></details><h2 id="重绘和回流是什么-会触发回流的操作有哪些-如果避免" tabindex="-1">重绘和回流是什么？会触发回流的操作有哪些？如果避免？ <a class="header-anchor" href="#重绘和回流是什么-会触发回流的操作有哪些-如果避免" aria-label="Permalink to &quot;重绘和回流是什么？会触发回流的操作有哪些？如果避免？&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><ul><li>重绘：当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要 UI 层面的像素绘制，因此损耗较小</li><li>回流：当元素的尺寸、结构或者触发某些属性时，浏览器会重新计算元素的位置，再进行绘制。</li><li>会触发回流的操作： <ul><li>浏览器窗口大小改变</li><li>元素尺寸、位置、内容发生改变</li><li>元素的字体大小发生改变</li><li>添加删除可见的 DOM 元素</li><li>激活 CSS 的伪类</li><li>JS 查询某些属性或者调用某些方法 <ul><li>clientWidth、clientHeight、clientTop、clientLeft</li><li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li><li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li><li>getComputedStyle()</li><li>getBoundingClientRect()</li><li>scrollTo()</li></ul></li></ul></li><li>避免： <ul><li>CSS <ul><li>避免使用 table 布局</li><li>避免将动画效果应用到 position 属性为 absolute 或者 fixed 元素</li></ul></li><li>JS <ul><li>避免频繁的修改样式，修改样式最好一次完成</li><li>尽量使用 class 进行样式修改</li><li>减少 DOM 的增删次数</li></ul></li></ul></li></ul></details><h2 id="浏览器端的存储方式有哪些" tabindex="-1">浏览器端的存储方式有哪些？ <a class="header-anchor" href="#浏览器端的存储方式有哪些" aria-label="Permalink to &quot;浏览器端的存储方式有哪些？&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><ul><li>cookie <ul><li>cookie 的兼容性比较好</li><li>存储量比较小，不同的浏览器存储量不同，基本都在 4KB 左右</li><li>由于 Cookie 会由浏览器作为请求头发送，因此存储过多会影响性能</li><li>只能存储字符串</li><li>存在安全问题，存储在 cookie 的数据可以被他人访问</li></ul></li><li>localStorage、sessionStorage <ul><li>API 更简单</li><li>更加安全</li><li>可存储的数据量更大</li><li>它们是 HTML5 的 API 所以存在一定的兼容性</li><li>受同源策略限制</li></ul></li><li>indexedDB <ul><li>可以存储更大量的结构化数据</li><li>IndexedDB 是异步的，操作时不会锁死浏览器</li><li>一系列操作中只要异步失败整个事务就会取消，数据库回滚到之前的状态</li><li>IndexedDB 不仅可以存储字符串还可以存储二进制数据</li><li>兼容性更差</li><li>受同源策略的限制</li></ul></li></ul></details><h2 id="什么是垃圾回收机制-什么是内存泄漏" tabindex="-1">什么是垃圾回收机制？什么是内存泄漏？ <a class="header-anchor" href="#什么是垃圾回收机制-什么是内存泄漏" aria-label="Permalink to &quot;什么是垃圾回收机制？什么是内存泄漏？&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><ul><li>JavaScript 是在创建变量的时候自动进行了内存的分配，并且在不使用他们的时候自动释放内存，释放的过程称为垃圾回收。</li><li>由于某种原因（如：）导致某个变量不在被使用的时候他所占据的内存不能够释放，称为内存泄漏</li></ul></details><h2 id="浏览器的缓存" tabindex="-1">浏览器的缓存 <a class="header-anchor" href="#浏览器的缓存" aria-label="Permalink to &quot;浏览器的缓存&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><p><a href="./../运维/浏览器缓存.html">缓存</a></p></details><h2 id="xss-和-csrf-是什么-它们的区别-原理是什么-如何防范" tabindex="-1">XSS 和 CSRF 是什么？它们的区别, 原理是什么？如何防范？ <a class="header-anchor" href="#xss-和-csrf-是什么-它们的区别-原理是什么-如何防范" aria-label="Permalink to &quot;XSS 和 CSRF 是什么？它们的区别, 原理是什么？如何防范？&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><ul><li>XSS：即跨站脚本攻击。攻击者在网站注入恶意代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时对用户浏览器进行控制或者获取用户隐私数据。 <ul><li>反射型 XSS：攻击者诱导用户点击恶意链接，或者提交表单，或者进入恶意网站，注入脚本进入被攻击者的网站。</li><li>存储型 XSS：攻击者把输入的恶意代码存储到服务器，当浏览器请求数据时，脚本从服务器返回给浏览者的页面执行。</li><li>DOM 型 XSS：攻击者通过恶意脚本修改页面的 DOM 结构，</li></ul></li><li>XSS 防御： <ul><li>现在的主流浏览器内置了防范 XSS 的措施。而且框架本身也对 XSS 做了防范。但对于开发者也应该采用一些措施来防止 XSS 攻击，例如：对输入输出检查转译。</li></ul></li><li>CSRF：跨站请求伪造。攻击者借助受害者的 Cookie 骗取服务器的信任，以受害者的名义伪造请求发送给受攻击的服务器</li><li>CSRF 防御： <ul><li>阻止第三方网站请求接口</li><li>添加 token 验证：CSRF 攻击之所以能成功是因为用户验证信息都是存在于 Cookie 中，攻击者可以利用用户自己的 Cookie 来进行校验，然后伪造请求。</li></ul></li><li>区别： <ul><li>原理不同，CSRF 是利用网站 A 本身的漏洞，去请求网站 A 的 api；XSS 是向目标网站注入 JS 代码然后执行 JS 里的代码</li><li>CSRF 需要用户登录目标网站获取 cookie，而 XSS 不需要登录</li><li>CSRF 攻击的目标是用户，XSS 的目标是服务器</li></ul></li></ul></details><h2 id="http-request-header-和-response-header-中常见的字段有哪些" tabindex="-1">http request header 和 response header 中常见的字段有哪些？ <a class="header-anchor" href="#http-request-header-和-response-header-中常见的字段有哪些" aria-label="Permalink to &quot;http request header 和 response header 中常见的字段有哪些？&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><ul><li>request: <ul><li>Accept: 能够接受的响应内容类型（Content-Types）</li><li>Content-Type: 请求体的类型 （用于 POST 和 PUT 请求中），例如：Content-Type: application/x-www-form-urlencoded</li><li>Host: 服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号。如果所请求的端口是对应的服务的标准端口，则端口号可被省略。自超文件传输协议版本 1.1（HTTP/1.1）开始便是必需字段。</li><li>User-Agent: 浏览器的浏览器身份标识字符串</li><li>If-Modified-Since</li><li>If-None-Match</li></ul></li><li>response: <ul><li>Access-Control-Allow-Origin: 指定哪些网站可参与到跨来源资源共享过程中</li><li>Content-Type: 当前内容的 MIME 类型，例如：Content-Type: text/html; charset=utf-8</li><li>Expires</li><li>Cache-Control: 向从服务器直到客户端在内的所有缓存机制告知，它们是否可以缓存这个对象</li><li>ETag</li><li>Last-Modified</li></ul></li><li>通用 <ul><li>Pragma</li><li>Content-Type</li></ul></li></ul></details>',30),r=[s];function o(u,d,h,c,n,m){return t(),i("div",null,r)}const y=l(a,[["render",o]]);export{S as __pageData,y as default};
