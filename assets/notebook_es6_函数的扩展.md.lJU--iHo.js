import{_ as a,c as s,o as n,a3 as e}from"./chunks/framework.CScuXPqu.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"notebook/es6/函数的扩展.md","filePath":"notebook/es6/函数的扩展.md"}'),l={name:"notebook/es6/函数的扩展.md"},i=e(`<h2 id="函数的默认值" tabindex="-1">函数的默认值 <a class="header-anchor" href="#函数的默认值" aria-label="Permalink to &quot;函数的默认值&quot;">​</a></h2><ul><li>默认值生效的条件是严格等于（===）undefined</li><li>参数变量是默认声明的，所以不能再次声明</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>function foo (x = 5) {</span></span>
<span class="line"><span>    let x  = 1 // error</span></span>
<span class="line"><span>    const x = 2 // error</span></span>
<span class="line"><span>}</span></span></code></pre></div><ul><li>使用参数默认值时函数不能有同名参数</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>function foo (x, x, y) {}   // 不报错</span></span>
<span class="line"><span>function foo (x, x, y = 0) {}   // 报错</span></span></code></pre></div><ul><li>参数默认值是惰性求值的，只有在用到的时候才会求值</li><li>参数默认值的位置应该是尾参数</li><li>设置参数默认值之后函数的 length 属性将返回默认值之前的参数个数，也就是说设置默认参数后 length 将失真</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>(function (a) {}).length // 1</span></span>
<span class="line"><span>(function (a = 5) {}).length // 0</span></span>
<span class="line"><span>(function (a, b, c = 5) {}).length // 2</span></span>
<span class="line"><span>(function(...args) {}).length // 0</span></span></code></pre></div><ul><li>设置参数的默认值，在函数进行声明初始化时参数会形成一个单独的作用域，等初始化结束作用域会消失。不设置默认值是不会出现的。</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>var x = 1</span></span>
<span class="line"><span>function f(x, y = x) {</span></span>
<span class="line"><span>    console.log(y)</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>f(2)</span></span></code></pre></div><h2 id="rest-参数" tabindex="-1">rest 参数 <a class="header-anchor" href="#rest-参数" aria-label="Permalink to &quot;rest 参数&quot;">​</a></h2><blockquote><p>rest 参数（形式为 ...变量名 ），用于获取函数的多余参数</p></blockquote><ul><li>rest 参数之后不能再有其他参数</li><li>函数的 length 属性不包含 rest 参数</li></ul><h2 id="严格模式" tabindex="-1">严格模式 <a class="header-anchor" href="#严格模式" aria-label="Permalink to &quot;严格模式&quot;">​</a></h2><blockquote><p>只要函数的参数使用了默认值，解构赋值，或者扩展运算符那么函数内部就不能设为严格模式</p></blockquote><h2 id="name-属性" tabindex="-1">name 属性 <a class="header-anchor" href="#name-属性" aria-label="Permalink to &quot;name 属性&quot;">​</a></h2><blockquote><p>返回函数的函数名</p></blockquote><ul><li>匿名函数赋值给变量，name 为变量名</li><li>具名函数赋值给变量，name 为具名函数原来的名字</li><li>Function 构造函数返回函数实例，name 为 anonymous</li><li>bind 返回的函数，name 属性会加上 bound 前缀</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>(new Function).name // &quot;anonymous&quot;</span></span>
<span class="line"><span>function foo() {};</span></span>
<span class="line"><span>foo.bind({}).name // &quot;bound foo&quot;</span></span>
<span class="line"><span>(function(){}).bind({}).name // &quot;bound &quot;</span></span></code></pre></div><h2 id="箭头函数" tabindex="-1">箭头函数 <a class="header-anchor" href="#箭头函数" aria-label="Permalink to &quot;箭头函数&quot;">​</a></h2><ul><li>如果箭头函数只有一行语句且不用返回值，语句前加 void</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>() =&gt; void doesNotReturn();</span></span></code></pre></div><ul><li>函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象</li><li>不可当作构造函数（不可以使用 new 命令）</li><li>不可以使用 arguments 对象</li><li>不可使用 yield 命令，箭头函数不能用作 Generator 函数</li></ul><h2 id="嵌套的箭头函数" tabindex="-1">嵌套的箭头函数 <a class="header-anchor" href="#嵌套的箭头函数" aria-label="Permalink to &quot;嵌套的箭头函数&quot;">​</a></h2><blockquote><p>前一个函数的输入是后一个函数的输入</p></blockquote><h2 id="绑定-this" tabindex="-1">绑定 this <a class="header-anchor" href="#绑定-this" aria-label="Permalink to &quot;绑定 this&quot;">​</a></h2><blockquote><p>箭头函数可以绑定 this 对象,大大减少了显示绑定 this 对象的写法(call, apply, bind)。 函数绑定运算符是并排的两个冒号，左边是一个对象，右边是一个函数。该运算符会将左边的对象作为上下文环境(this)绑定到右边的函数上。</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>foo::bar</span></span>
<span class="line"><span>// 等同于</span></span>
<span class="line"><span>bar.bind(foo)</span></span></code></pre></div><blockquote><p>如果双冒号左边为空右边是一个对象的方法，则等于将该方法绑定在该对象上</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>::console.log</span></span>
<span class="line"><span>// 等同于</span></span>
<span class="line"><span>console::console.log</span></span>
<span class="line"><span>console.log.bind(console)</span></span></code></pre></div><h2 id="尾调用优化" tabindex="-1">尾调用优化 <a class="header-anchor" href="#尾调用优化" aria-label="Permalink to &quot;尾调用优化&quot;">​</a></h2><blockquote><p>在函数的最后一步调用另一个函数。尾调用是最后一步操作。尾调用调用帧只有一项，可以节省内存。</p></blockquote><h4 id="尾递归" tabindex="-1">尾递归 <a class="header-anchor" href="#尾递归" aria-label="Permalink to &quot;尾递归&quot;">​</a></h4><blockquote><p>递归调用非常消耗内存很容易发生栈溢出错误，但是尾递归永远只存在一个调用帧</p></blockquote><ul><li>递归函数的改写：需要将中间变量改写为函数的参数。</li></ul><h4 id="严格模式-1" tabindex="-1">严格模式 <a class="header-anchor" href="#严格模式-1" aria-label="Permalink to &quot;严格模式&quot;">​</a></h4><blockquote><p>ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</p></blockquote>`,36),o=[i];function t(p,c,h,u,d,r){return n(),s("div",null,o)}const k=a(l,[["render",t]]);export{g as __pageData,k as default};
