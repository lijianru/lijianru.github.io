import{_ as a,c as e,o as s,a3 as t}from"./chunks/framework.CScuXPqu.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"frame/react/01.JSX.md","filePath":"frame/react/01.JSX.md"}'),l={name:"frame/react/01.JSX.md"},i=t(`<h2 id="jsx-的表达式" tabindex="-1">JSX 的表达式 <a class="header-anchor" href="#jsx-的表达式" aria-label="Permalink to &quot;JSX 的表达式&quot;">​</a></h2><h4 id="jsx-表达式" tabindex="-1">JSX 表达式 <a class="header-anchor" href="#jsx-表达式" aria-label="Permalink to &quot;JSX 表达式&quot;">​</a></h4><ul><li>推荐在 JSX 代码的外面扩上小括号，这样可以防止分号自动插入的 bug。 JSX 最终会被转换为 JavaScript 的 React.createElement()方法。</li></ul><h4 id="jsx-防止注入攻击" tabindex="-1">JSX 防止注入攻击 <a class="header-anchor" href="#jsx-防止注入攻击" aria-label="Permalink to &quot;JSX 防止注入攻击&quot;">​</a></h4><ul><li>可以放心的使用用户输入，React DOM 在渲染之前会过滤所有的传入值，所有的内容在渲染之前都被转换为字符串，这样可以防止 XSS 攻击。</li></ul><h4 id="在运行时选择类型" tabindex="-1">在运行时选择类型 <a class="header-anchor" href="#在运行时选择类型" aria-label="Permalink to &quot;在运行时选择类型&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// 如果需要通过一个表达式来确定React元素的类型，可以先将其赋值给开头为大写的变量</span></span>
<span class="line"><span>const SpecificStory = components[props.storyType];</span></span>
<span class="line"><span>return &lt;SpecificStory story={props.story} /&gt;;</span></span></code></pre></div><h2 id="jsx-的属性" tabindex="-1">JSX 的属性 <a class="header-anchor" href="#jsx-的属性" aria-label="Permalink to &quot;JSX 的属性&quot;">​</a></h2><h4 id="class-和-for" tabindex="-1">class 和 for <a class="header-anchor" href="#class-和-for" aria-label="Permalink to &quot;class 和 for&quot;">​</a></h4><blockquote><p>在 JS 中 class 和 for 都是关键字，在 JSX 中需要做对应的转换</p></blockquote><ul><li>class 改为 className</li><li>for 改为 htmlFor</li></ul><h4 id="javascript-表达式作为-props" tabindex="-1">javascript 表达式作为 props <a class="header-anchor" href="#javascript-表达式作为-props" aria-label="Permalink to &quot;javascript 表达式作为 props&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>&lt;MyComponent foo={1 + 2 + 3 + 4} /&gt;</span></span></code></pre></div><h4 id="字符串字面量" tabindex="-1">字符串字面量 <a class="header-anchor" href="#字符串字面量" aria-label="Permalink to &quot;字符串字面量&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// 它们等价</span></span>
<span class="line"><span>&lt;MyComponent message=&quot;&amp;lt;3&quot; /&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>&lt;MyComponent message={&#39;&lt;3&#39;} /&gt;</span></span></code></pre></div><h4 id="属性默认为-true" tabindex="-1">属性默认为‘true’ <a class="header-anchor" href="#属性默认为-true" aria-label="Permalink to &quot;属性默认为‘true’&quot;">​</a></h4><ul><li>如果没有给属性传值它默认为 true</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// 下面两个等价</span></span>
<span class="line"><span>&lt;MyTextBox autocomplete /&gt;</span></span>
<span class="line"><span>&lt;MyTextBox autocomplete={true} /&gt;</span></span></code></pre></div><h4 id="展开属性" tabindex="-1">展开属性 <a class="header-anchor" href="#展开属性" aria-label="Permalink to &quot;展开属性&quot;">​</a></h4><ul><li>可以使用...来传递整个属性对象，但是一定要谨慎使用，避免传递无用或多于的属性。</li></ul><h4 id="自定义的-html-属性" tabindex="-1">自定义的 HTML 属性 <a class="header-anchor" href="#自定义的-html-属性" aria-label="Permalink to &quot;自定义的 HTML 属性&quot;">​</a></h4><ul><li>在 JSX 中往 DOM 元素中传入自定义属性 React 是不会渲染的，需要使用 data-前缀</li></ul><h2 id="jsx-中的子代" tabindex="-1">JSX 中的子代 <a class="header-anchor" href="#jsx-中的子代" aria-label="Permalink to &quot;JSX 中的子代&quot;">​</a></h2><p>在包含开始和结束标签的 JSX 表达式中这两个标签的内容被传递为专门的属性： props.children，有几种不同的方式来传递子代。</p><h4 id="字符串字面量-1" tabindex="-1">字符串字面量 <a class="header-anchor" href="#字符串字面量-1" aria-label="Permalink to &quot;字符串字面量&quot;">​</a></h4><ul><li>JSX 会移除空行和开始与结尾处的空格，标签临近的新行也会被移除。</li></ul><h4 id="jsx-子代" tabindex="-1">JSX 子代 <a class="header-anchor" href="#jsx-子代" aria-label="Permalink to &quot;JSX 子代&quot;">​</a></h4><h4 id="javascript-表达式作为子代" tabindex="-1">JavaScript 表达式作为子代 <a class="header-anchor" href="#javascript-表达式作为子代" aria-label="Permalink to &quot;JavaScript 表达式作为子代&quot;">​</a></h4><h4 id="函数作为子代" tabindex="-1">函数作为子代 <a class="header-anchor" href="#函数作为子代" aria-label="Permalink to &quot;函数作为子代&quot;">​</a></h4><h4 id="布尔类型、null-以及-undefined-将会忽略" tabindex="-1">布尔类型、Null 以及 Undefined 将会忽略 <a class="header-anchor" href="#布尔类型、null-以及-undefined-将会忽略" aria-label="Permalink to &quot;布尔类型、Null 以及 Undefined 将会忽略&quot;">​</a></h4><ul><li>false, null, undefined, and true 是合法的子元素。但它们并不会被渲染。</li><li>值得注意的是有一些 “falsy” 值，如数字 0，仍然会被 React 渲染。</li></ul><h2 id="注释" tabindex="-1">注释 <a class="header-anchor" href="#注释" aria-label="Permalink to &quot;注释&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>{/* &lt;div&gt;123&lt;/div&gt; */}</span></span></code></pre></div><h2 id="深入-jsx" tabindex="-1">深入 JSX <a class="header-anchor" href="#深入-jsx" aria-label="Permalink to &quot;深入 JSX&quot;">​</a></h2><p>实际上，JSX 仅仅只是 React.createElement(component, props, ...children)函数的语法糖。</p><ul><li>用户定义的组件必须以大写字母开头。</li><li>第一个参数制定了 React 元素的类型，大写字母开头的 JSX 标签意味着他们是 React 组件。这些标签会被编译为对命名变量的直接引用。但必须将其包含在作用域内。</li><li>每个组件必须拥有一个唯一的父节点。</li></ul>`,36),n=[i];function o(r,c,p,h,d,u){return s(),e("div",null,n)}const f=a(l,[["render",o]]);export{m as __pageData,f as default};
