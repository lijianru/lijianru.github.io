import{_ as e,c as a,o as t,a3 as o}from"./chunks/framework.CScuXPqu.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"frame/react/08.react组件性能优化.md","filePath":"frame/react/08.react组件性能优化.md"}'),n={name:"frame/react/08.react组件性能优化.md"},s=o(`<h2 id="profiler" tabindex="-1">Profiler <a class="header-anchor" href="#profiler" aria-label="Permalink to &quot;Profiler&quot;">​</a></h2><p>测量渲染一个 React 应用多久渲染一次以及渲染一次的“代价”。 它的目的是识别出应用中渲染较慢的部分，或是可以使用类似 memo 优化的部分，并从相关优化中获益。</p><h2 id="单个组件的性能优化" tabindex="-1">单个组件的性能优化 <a class="header-anchor" href="#单个组件的性能优化" aria-label="Permalink to &quot;单个组件的性能优化&quot;">​</a></h2><h3 id="shouldcomponentupdate" tabindex="-1">shouldComponentUpdate <a class="header-anchor" href="#shouldcomponentupdate" aria-label="Permalink to &quot;shouldComponentUpdate&quot;">​</a></h3><blockquote><p>shouldComponentUpdate 决定了组件什么时候不需要渲染</p></blockquote><h3 id="对于无状态组件" tabindex="-1">对于无状态组件 <a class="header-anchor" href="#对于无状态组件" aria-label="Permalink to &quot;对于无状态组件&quot;">​</a></h3><blockquote><p>无状态组件 shouldComponentUpdate 默认返回 true，只要 props 改变就会渲染</p></blockquote><h3 id="react-redux-的-connect-函数" tabindex="-1">react-redux 的 connect 函数 <a class="header-anchor" href="#react-redux-的-connect-函数" aria-label="Permalink to &quot;react-redux 的 connect 函数&quot;">​</a></h3><blockquote><p>connect 函数实际产生了一个无名的 react 组件类，这个类定制了 shouldComponentUpdate 函数的实现。 react-redux 提供的 shouldComponentUpdate 函数使用浅层比较（===）对比 props 是否发生变化。 所以对于 props 类型为复杂对象，这样的比较总是认为 props 发生了变化。</p></blockquote><ul><li>在使用 props 的时候可以使 props 指向同一 JS 对象</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// 确保这个初始化只执行一次，不放在render中</span></span>
<span class="line"><span>const fooStyle = {color: &#39;red&#39;}</span></span>
<span class="line"><span>&lt;Foo style={fooStyle} /&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>&lt;TodoItem</span></span>
<span class="line"><span>    key={item.id}</span></span>
<span class="line"><span>    onToggle={onToggleTodo}</span></span>
<span class="line"><span>/&gt;</span></span></code></pre></div><ul><li>将组件自己的处理函数内聚到自己的组件内部，减少暴露到外部的 props</li></ul><h2 id="多个-react-组件的性能优化" tabindex="-1">多个 react 组件的性能优化 <a class="header-anchor" href="#多个-react-组件的性能优化" aria-label="Permalink to &quot;多个 react 组件的性能优化&quot;">​</a></h2><blockquote><p>对于原组件根节点的类型发生变化，组件会直接被卸载。对于节点类型未发生改变的情况可分为两类：1.是节点为 DOM 类型，react 会保留节点对应的 DOM 元素，值对比节点的属性和内容，然后更改修改的部分。 2.节点为 react 组件，会经历一系列钩子函数。</p></blockquote><ul><li>避免组件根节点类型的变化</li><li>添加一个唯一的 key</li></ul><h2 id="使用-reselect-提高获取性能" tabindex="-1">使用 reselect 提高获取性能 <a class="header-anchor" href="#使用-reselect-提高获取性能" aria-label="Permalink to &quot;使用 reselect 提高获取性能&quot;">​</a></h2><blockquote><p>优化 mapStateToProps 函数。</p></blockquote>`,17),l=[s];function r(p,c,i,d,h,u){return t(),a("div",null,l)}const b=e(n,[["render",r]]);export{m as __pageData,b as default};
