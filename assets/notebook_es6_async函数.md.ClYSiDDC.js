import{_ as a,c as s,o as n,a3 as i}from"./chunks/framework.CScuXPqu.js";const y=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"notebook/es6/async函数.md","filePath":"notebook/es6/async函数.md"}'),e={name:"notebook/es6/async函数.md"},l=i(`<h2 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-label="Permalink to &quot;简介&quot;">​</a></h2><ul><li>async/await 是基于 Promise 实现的，不能用于普通的回调函数</li><li>async/await 与 Promise 一样是非阻塞的</li><li>async/await 使得异步代码看起来像同步代码</li></ul><h2 id="基本用法" tabindex="-1">基本用法 <a class="header-anchor" href="#基本用法" aria-label="Permalink to &quot;基本用法&quot;">​</a></h2><blockquote><p>async 函数就是 Generator 函数的语法糖，它的改进如下：</p></blockquote><ul><li>内置执行器，与普通函数一样。</li><li>更语义，async 和 await ，比起星号和 yield。</li><li>更广的适应性，async 函数的 await 命令后面，可以是 Promise 对象和原始类型的值</li><li>返回值是 Promise，可以用 then 指定下一步操作</li></ul><h4 id="async-的使用形式" tabindex="-1">async 的使用形式 <a class="header-anchor" href="#async-的使用形式" aria-label="Permalink to &quot;async 的使用形式&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// 函数声明</span></span>
<span class="line"><span>async function foo() {}</span></span>
<span class="line"><span>// 函数表达式</span></span>
<span class="line"><span>const foo = async function () {};</span></span>
<span class="line"><span>// 对象的方法</span></span>
<span class="line"><span>let obj = { async foo() {} };</span></span>
<span class="line"><span>obj.foo().then(...)</span></span>
<span class="line"><span>// 箭头函数</span></span>
<span class="line"><span>const foo = async () =&gt; {};</span></span>
<span class="line"><span>// Class 的方法</span></span>
<span class="line"><span>class Storage {</span></span>
<span class="line"><span>    async getAvatar(name) {</span></span>
<span class="line"><span>        const cache = await this.cachePromise;</span></span>
<span class="line"><span>        return cache.match(\`/avatars/\${name}.jpg\`);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><h4 id="返回-promise-对象" tabindex="-1">返回 Promise 对象 <a class="header-anchor" href="#返回-promise-对象" aria-label="Permalink to &quot;返回 Promise 对象&quot;">​</a></h4><blockquote><p>async 函数返回一个 Promise 对象，async 函数内部 return 语句的返回值会成为 then 方法回调函数的参数。 async 函数内部抛出错误会导致返回的 Promise 对象变为 reject 状态，错误对象会被 catch 方法接收到。</p></blockquote><h4 id="promise-对象状态变化" tabindex="-1">Promise 对象状态变化 <a class="header-anchor" href="#promise-对象状态变化" aria-label="Permalink to &quot;Promise 对象状态变化&quot;">​</a></h4><blockquote><p>async 函数返回的 Promise 对象，必须等到内部所有 await 命令后面的 Promise 对象执行完， 才会发生状态改变，除非遇到 return 语句或者抛出错误。也就是说，只有 async 函数内部的异步操作执行完， 才会执行 then 方法指定的回调函数。</p></blockquote><h4 id="await-命令" tabindex="-1">await 命令 <a class="header-anchor" href="#await-命令" aria-label="Permalink to &quot;await 命令&quot;">​</a></h4><blockquote><p>await 命令后面是一个 Promise 对象。如果不是，会被转成一个立即 resolve 的 Promise 对象。 只要一个 await 语句后面的 Promise 变为 reject ，那么整个 async 函数都会中断执行。</p></blockquote><h4 id="错误处理" tabindex="-1">错误处理 <a class="header-anchor" href="#错误处理" aria-label="Permalink to &quot;错误处理&quot;">​</a></h4><blockquote><p>如果 await 后面的异步操作出错，那么等同于 async 函数返回的 Promise 对象被 reject 且后续操作会被中断</p></blockquote><ul><li>await 放在 try...catch 结构里面</li><li>await 后面的 Promise 对象再跟一个 catch 方法</li></ul><h4 id="使用注意点" tabindex="-1">使用注意点 <a class="header-anchor" href="#使用注意点" aria-label="Permalink to &quot;使用注意点&quot;">​</a></h4><ul><li>最好把 await 命令放在 try...catch 代码块中</li><li>多个 await 命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// 写法一</span></span>
<span class="line"><span>let [foo, bar] = await Promise.all([getFoo(), getBar()]);</span></span>
<span class="line"><span>// 写法二</span></span>
<span class="line"><span>let fooPromise = getFoo();</span></span>
<span class="line"><span>let barPromise = getBar();</span></span>
<span class="line"><span>let foo = await fooPromise;</span></span>
<span class="line"><span>let bar = await barPromise;</span></span></code></pre></div><ul><li>await 命令只能用在 async 函数之中，如果用在普通函数，就会报错</li></ul><h2 id="async-实现的原理" tabindex="-1">async 实现的原理 <a class="header-anchor" href="#async-实现的原理" aria-label="Permalink to &quot;async 实现的原理&quot;">​</a></h2><ul><li>async 函数的实现原理就是将 Generator 函数和自动执行器，包装在一个函数里。</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 等同于(spawn函数就是自动执行器)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> spawn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div>`,23),t=[l];function p(o,c,r,h,k,d){return n(),s("div",null,t)}const m=a(e,[["render",p]]);export{y as __pageData,m as default};
