import{_ as s,c as i,o as a,a1 as l}from"./chunks/framework.Bw_Y1HHt.js";const y=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"daily/javaScript-08-其他.md","filePath":"daily/javaScript-08-其他.md"}'),t={name:"daily/javaScript-08-其他.md"},n=l(`<h2 id="经常使用的-es6-新特性" tabindex="-1">经常使用的 ES6 新特性 <a class="header-anchor" href="#经常使用的-es6-新特性" aria-label="Permalink to &quot;经常使用的 ES6 新特性&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><ul><li>let, const</li><li>模板字符串</li><li>箭头函数</li><li>函数参数的默认值</li><li>扩展/剩余运算符</li><li>解构</li><li>class</li><li>promise</li></ul></details><h2 id="深度优先遍历和广度优先遍历" tabindex="-1">深度优先遍历和广度优先遍历 <a class="header-anchor" href="#深度优先遍历和广度优先遍历" aria-label="Permalink to &quot;深度优先遍历和广度优先遍历&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><p>以遍历一个 dom 节点为例：</p><ul><li>深度优先遍历：从某个顶点 v 出发，首先访问该顶点然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和 v 有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> deepTraversal</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">nodeList</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (node </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    nodeList.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> children </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node.children;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> children.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      deepTraversal1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(children[i], nodeList);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nodeList;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><ul><li>广度优先遍历：从图中某顶点 v 出发，在访问了 v 之后依次访问 v 的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点， 并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。 如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> widthTraversal</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nodes </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> stack </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (node) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    stack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (stack.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> item </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> stack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">shift</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> children </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> item.children;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      nodes.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(item);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> children.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        stack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(children[i]);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nodes;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div></details><h2 id="settimeout-倒计时为什么会出现误差" tabindex="-1">setTimeout 倒计时为什么会出现误差 <a class="header-anchor" href="#settimeout-倒计时为什么会出现误差" aria-label="Permalink to &quot;setTimeout 倒计时为什么会出现误差&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><ul><li>setTimeout 只是将事件插入了任务队列，必须等到当前代码(执行栈)执行完，才会执行它指定的回调函数。要是当前的代码消耗时间很长， setTimeout 也有可能要等很久，所以并没有办法保证回调函数一定在 setTimeout 指定的时间执行，所以 setTimeout 的第二个参数表示的是最小时间。</li><li>HTML 标准规定了 setTimeout 的第二个参数的最小值不能小于 4ms，如果低于这个值则默认为 4ms。</li></ul></details><h2 id="为什么需要组件化和模块化" tabindex="-1">为什么需要组件化和模块化？ <a class="header-anchor" href="#为什么需要组件化和模块化" aria-label="Permalink to &quot;为什么需要组件化和模块化？&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><ul><li>组件化能提高代码的复用性，降低维护的成本</li><li>模块化能避免变量污染和命名冲突，提高代码的复用率，降低维护成本，方便进行依赖管理</li></ul></details><h2 id="简述对-web-worker-的理解" tabindex="-1">简述对 Web Worker 的理解 <a class="header-anchor" href="#简述对-web-worker-的理解" aria-label="Permalink to &quot;简述对 Web Worker 的理解&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><ul><li>Web Worker 的作用就是为 JavaScript 创造多线程环境，在主线程运行的同时允许 Worker 线程在后台运行，两者互不干扰。</li><li>遵循同源策略</li><li>worker 线程无法读取主线程所在网页的 DOM 元素，无法使用 document、window 等对象</li><li>worker 线程不与主线程在同一个上下文环境，它们仅能通过消息机制完成通信</li><li>worker 线程可以通过 XMLHttpRequest 对象发出 ajax 请求</li></ul></details><h2 id="es6-模块和-commonjs-模块的差异是什么" tabindex="-1">ES6 模块和 CommonJS 模块的差异是什么？ <a class="header-anchor" href="#es6-模块和-commonjs-模块的差异是什么" aria-label="Permalink to &quot;ES6 模块和 CommonJS 模块的差异是什么？&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><ul><li>导出导入的方式不同，ES6 使用 export/import。而 CommonJS 使用 module.export/require</li><li>ES6 模块自动采用严格模式，无论模块开头是否写了 use strict</li><li>ES6 模块的顶层 this 指向 undefined。而 CommonJS 模块的顶层 this 指向当前模块。</li><li>ES6 模块在编译的时候就能确定模块的依赖关系，以及输入输出的变量。而 CommonJS 模块是运行时加载。</li><li>ES6 模块输出的是值的引用，如果原始的值改变了，import 加载的值也会改变。而 CommonJS 模块一旦输出一个值，模块内部变化就影响不到这个值了。</li></ul></details><h2 id="解决跨域的方法有哪些" tabindex="-1">解决跨域的方法有哪些？ <a class="header-anchor" href="#解决跨域的方法有哪些" aria-label="Permalink to &quot;解决跨域的方法有哪些？&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><ul><li>CORS：只要服务器设置了 Access-Control-Allow-Origin 就可以开启 CORS。该属性表示那些域名可以访问资源。 <ul><li>简单请求，同时满足以下两个条件就属于简单请求 <ul><li>使用以下方法 <ul><li>get</li><li>head</li><li>post</li></ul></li><li>Content-Type 的值为以下三者之一 <ul><li>text/plain</li><li>multipart/form-data</li><li>application/x-www-form-urlencoded</li></ul></li></ul></li><li>复杂请求，不符合以上条件的就是复杂请求。复杂请求会在正式通信之前增加一次 option 方法的预检查，通过该请求来知道是否允许跨域请求。</li></ul></li></ul><p>存在的问题：对于 CORS 请求，只能拿到 response header 中的 6 个基本字段(Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma)，如果想拿到其他的字段就必须在 Access-Control-Expose-Headers 里指定需要的字段</p><ul><li>nginx 反向代理</li><li>jsonp: 只支持 get 请求</li><li>websocket</li><li>postMessage</li><li>node 中间件</li></ul></details><h2 id="堆和栈的区别" tabindex="-1">堆和栈的区别 <a class="header-anchor" href="#堆和栈的区别" aria-label="Permalink to &quot;堆和栈的区别&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><ul><li>栈为自动分配的内存空间，它由系统自动释放</li><li>堆则是动态分配的内存，大小不定也不会自动释放，一般由程序员分配释放，若程序员不释放，程序结束时可能由 OS 回收</li></ul></details><h2 id="babel-编译原理" tabindex="-1">Babel 编译原理 <a class="header-anchor" href="#babel-编译原理" aria-label="Permalink to &quot;Babel 编译原理&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><ul><li>babylon 将 ES6/ES7 代码解析成 AST 抽象语法树</li><li>babel-traverse 对 AST 抽象语法树 进行遍历转译，得到新的 AST 抽象语法树</li><li>新 AST 抽象语法树 通过 babel-generator 转换成 ES5</li></ul></details><h2 id="代码复用的方式" tabindex="-1">代码复用的方式 <a class="header-anchor" href="#代码复用的方式" aria-label="Permalink to &quot;代码复用的方式&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><ul><li>封装</li><li>继承</li><li>借用（apply/call）</li></ul></details><h2 id="常见的设计模式有哪些" tabindex="-1">常见的设计模式有哪些？ <a class="header-anchor" href="#常见的设计模式有哪些" aria-label="Permalink to &quot;常见的设计模式有哪些？&quot;">​</a></h2><details class="details custom-block"><summary>查看详情</summary><ul><li>JS 工厂模式</li><li>JS 构造函数模式</li><li>JS 原型模式</li><li>观察者模式</li><li>发布订阅模式</li></ul></details>`,22),e=[n];function h(k,p,r,d,E,o){return a(),i("div",null,e)}const g=s(t,[["render",h]]);export{y as __pageData,g as default};
