import{_ as a,c as e,o as i,a1 as l,a4 as t}from"./chunks/framework.Bw_Y1HHt.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"blog/javascript中的数据类型之number.md","filePath":"blog/javascript中的数据类型之number.md"}'),r={name:"blog/javascript中的数据类型之number.md"},o=l('<h2 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h2><p>在 javascript 中 Number 是一种定义为 <a href="https://zh.wikipedia.org/wiki/%E9%9B%99%E7%B2%BE%E5%BA%A6%E6%B5%AE%E9%BB%9E%E6%95%B8" target="_blank" rel="noreferrer">64 位双精度浮点型</a>的数字数据类型。并遵循 IEEE 二进制浮点数算术标准（IEEE754）。IEEE 754 规定了四种表示浮点数值的方式：单精确度（32 位）、双精确度（64 位）、延伸单精确度（43 比特以上，很少使用）与延伸双精确度（79 比特以上，通常以 80 位实现）。</p><h2 id="双精度浮点数" tabindex="-1">双精度浮点数 <a class="header-anchor" href="#双精度浮点数" aria-label="Permalink to &quot;双精度浮点数&quot;">​</a></h2><p>双精度浮点数采用 64 位来存储一个浮点数。它可以表示二进位制的 53 位有效数字，其可以表示的数字的绝对值范围为 [2^-1024,2^1024]。</p><h3 id="格式" tabindex="-1">格式 <a class="header-anchor" href="#格式" aria-label="Permalink to &quot;格式&quot;">​</a></h3><p><img src="'+t+'" alt="double.jpg"></p><ul><li>sign bit（符号）：用来表示正负号，一位，0 代表数值为正，1 代表数值为负。</li><li>exponent（指数）：用来表示次方数，十一位，64 位双精度浮点数固定偏移为 1023.</li><li>mantissa（分数）：用来表示精确度，五十二位。由于采用科学计数法表示是它总是以 1.x 开头的，所以在存储时只会存储小数点后 52 位，第 53 位及以后的数字不能存储，如果是 1 就向前进一位，是 0 就舍弃。</li></ul><p>用一个公式可计算为：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>(-1)^sign * 2^exponent * mantissa</span></span></code></pre></div><h3 id="_64-位双精度浮点数存储的例子" tabindex="-1">64 位双精度浮点数存储的例子 <a class="header-anchor" href="#_64-位双精度浮点数存储的例子" aria-label="Permalink to &quot;64 位双精度浮点数存储的例子&quot;">​</a></h3><h4 id="_0-1" tabindex="-1">0.1 <a class="header-anchor" href="#_0-1" aria-label="Permalink to &quot;0.1&quot;">​</a></h4><ul><li>将 0.1 转为二进制：<code>0.00011001100110011001100110011001100110011001100110011001</code>（1001 无限循环）</li><li>将二进制书采用科学技术法表示：<code>2^-4 * 1.1001100110011001100110011001100110011001100110011001</code>（1001 无限循环）</li><li>从科学计数法得到各部分的值 <ul><li>sign 位：0</li><li>exponent 位：<code>-4 + 1023 = 1019</code>，再转为二进制为 <code>01111111011</code></li><li>mantissa 位：<code>1001100110011001100110011001100110011001100110011010</code>（第 53 位及以后的数字不能存储，如果是 1 就向前进一位，是 0 就舍弃）</li></ul></li><li>最终得到的在计算机中存储的二进制数为：<code>0 01111111011 1001100110011001100110011001100110011001100110011010</code></li></ul><h4 id="_11-3" tabindex="-1">11.3 <a class="header-anchor" href="#_11-3" aria-label="Permalink to &quot;11.3&quot;">​</a></h4><ul><li>将 11.3 转为二进制：<code>1011.010011001100110011001100110011001100110011001100110011</code>（1001 无限循环）</li><li>将二进制书采用科学技术法表示：<code>2^3 * 1.011010011001100110011001100110011001100110011001100110011</code>（1001 无限循环）</li><li>从科学计数法得到各部分的值 <ul><li>sign 位：0</li><li>exponent 位：<code>3 + 1023 = 1026</code>，再转为二进制为 <code>10000000010</code></li><li>mantissa 位：<code>0110100110011001100110011001100110011001100110011010</code>（第 53 位及以后的数字不能存储，如果是 1 就向前进一位，是 0 就舍弃）</li></ul></li><li>最终得到的在计算机中存储的二进制数为：<code>0 10000000010 0110100110011001100110011001100110011001100110011010</code></li></ul><p>这里有一个在线测试的<a href="http://bartaz.github.io/ieee754-visualization/" target="_blank" rel="noreferrer">工具</a></p><h2 id="常见问题" tabindex="-1">常见问题 <a class="header-anchor" href="#常见问题" aria-label="Permalink to &quot;常见问题&quot;">​</a></h2><h3 id="为什么-0-1-0-2-0-3" tabindex="-1">为什么 0.1 + 0.2 != 0.3 <a class="header-anchor" href="#为什么-0-1-0-2-0-3" aria-label="Permalink to &quot;为什么 0.1 + 0.2 != 0.3&quot;">​</a></h3><details class="details custom-block"><summary>查看详情</summary><p>计算时会首先将十进制数转为二进制再计算，由于分数位只能存储 52 位，第 53 位会发生“0 舍 1 入”，所以某些数字在转为二进制时会发生精度丢失。</p></details><h3 id="为什么最大安全数字是-2-53-1-不是-2-52-1" tabindex="-1">为什么最大安全数字是 2^53-1 不是 2^52-1 <a class="header-anchor" href="#为什么最大安全数字是-2-53-1-不是-2-52-1" aria-label="Permalink to &quot;为什么最大安全数字是 2^53-1 不是 2^52-1&quot;">​</a></h3><details class="details custom-block"><summary>查看详情</summary><p>由于分数位只能存储 52 位，第 53 位会发生“0 舍 1 入”，所以最大的安全分数位为 52 个 1，也就是 2^53-1。</p></details><h3 id="为什么-1-335-tofixed-2-得到的是-1-33" tabindex="-1">为什么 (1.335).toFixed(2) 得到的是 1.33 <a class="header-anchor" href="#为什么-1-335-tofixed-2-得到的是-1-33" aria-label="Permalink to &quot;为什么 (1.335).toFixed(2) 得到的是 1.33&quot;">​</a></h3><details class="details custom-block"><summary>查看详情</summary><p>1.335 先转为二进制存储在计算机中，而在转换时会发生精度丢失，实际上存储的是 <code>1.334999999999999964472863211994990...</code> 所以在四舍五入时得到的是 1.33。（(1.335).toPrecision(52)）</p></details><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://zhuanlan.zhihu.com/p/351127362" target="_blank" rel="noreferrer">javascript 双精度浮点数剖析</a></li><li><a href="https://zh.wikipedia.org/wiki/%E9%9B%99%E7%B2%BE%E5%BA%A6%E6%B5%AE%E9%BB%9E%E6%95%B8" target="_blank" rel="noreferrer">双精度浮点数</a></li><li><a href="https://zh.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noreferrer">IEEE754</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/toPrecision" target="_blank" rel="noreferrer">Number.prototype.toPrecision()</a></li></ul>',24),s=[o];function n(c,d,h,p,u,b){return i(),e("div",null,s)}const E=a(r,[["render",n]]);export{_ as __pageData,E as default};
